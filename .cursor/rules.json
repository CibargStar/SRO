{
    "rules": [
      "Проект SRO (BM Tools) состоит из двух приложений: backend и frontend. Backend: Node.js 20+, TypeScript 5.9.3+, Express 5.1.0+, Prisma ORM 6.18.0 (SQLite по умолчанию, возможен Postgres), Zod 3.24.1+, express-validator 7.3.0+, Winston 3.18.3+, Helmet 8.1.0+, express-rate-limit 8.2.1+, dotenv-safe 9.1.0+, dotenv 16.4.5+, Jest 30.2.0+, ts-jest 29.4.5, Supertest 7.1.4+. Frontend: React 19.2.0+, TypeScript 5.9.3+, React Router 7.9.6+, Material-UI 7.3.5+, Emotion 11.14.0+, TanStack Query 5.90.10+, Zustand 5.0.8+, React Hook Form 7.66.1+, @hookform/resolvers 5.2.2+, Zod 3.24.1+, Vite 7.2.2+, Jest 30.2.0+, @testing-library/react 16.1.0+, @testing-library/jest-dom 6.6.3+, @testing-library/user-event 14.5.2+.",
      "При работе с проектом SRO ассистент ОБЯЗАН активно использовать доступные MCP-сервера. Нельзя игнорировать MCP, если они помогают решить задачу над проектом.",
      "Для работы с файловой структурой проекта (поиск, чтение, анализ, рефакторинг) ассистент должен использовать MCP `filesystem`. Перед тем как что-либо менять или предлагать глобальный рефакторинг, необходимо получить через `filesystem` актуальный список файлов и содержимое соответствующих модулей.",
      "Для планирования сложных задач, многошаговых рефакторингов и разбора инцидентов ассистент должен использовать MCP `sequential-thinking`, чтобы явно составить план действий прежде, чем предлагать патчи.",
      "Для получения актуальной документации и примеров (Prisma, Zod, React, TanStack Query, Vite, Jest и т.п.) ассистент должен по возможности использовать MCP `context7` и/или `@21st-dev/magic`, а не полагаться только на встроенные знания.",
      "Для работы с базой данных (схема, миграции, запросы, диагностика) ассистент должен при наличии использовать MCP `postgres` или другой MCP для БД. Нельзя предполагать схему \"на глаз\" — нужно сверяться с реальной схемой проекта.",
      "Для анализа реального поведения UI или веб-страниц ассистент может использовать MCP `puppeteer`. При необходимости проверить реальный контент, верстку или поведение, нужно отдавать предпочтение этому MCP.",
      "Ключевое правило: если ассистент ДОБАВЛЯЕТ или МЕНЯЕТ какой-либо функционал, он ОБЯЗАН убедиться, что изменения согласованы во ВСЁМ проекте, а не только в одном файле. Это означает поиск и обновление всех релевантных мест в коде.",
      "При добавлении нового модуля или изменении существующего (например, модуль логирования, новая сущность домена, изменение DTO, изменение схемы БД, новый middleware, изменение маршрутов) ассистент должен:\n1) Использовать MCP `filesystem`, чтобы найти все файлы, где этот функционал используется или должен использоваться (по именам функций, типов, интерфейсов, путям импорта, строковым константам маршрутов и т.д.).\n2) Предложить патчи или новые версии ВСЕХ затронутых файлов, а не только одного примера.\n3) Обновить тесты (Jest/Testing Library/Playwright) и типы/схемы, если они завязаны на изменённый функционал.\n4) Убедиться, что не осталось старых вызовов или устаревших путей (например, старые console.log после внедрения Winston).",
      "Пример: если ассистент внедряет модуль логирования на базе Winston, он обязан с помощью MCP `filesystem` найти все вхождения `console.log`, `console.error`, `console.warn` и подобных в backend, и заменить их на вызовы Winston в соответствующих местах (или явно указать патчи для каждого файла). Нельзя ограничиваться только одним файлом-примером.",
      "Пример: если ассистент меняет название поля в Zod-схеме или Prisma-модели, он обязан найти все места, где это поле используется (контроллеры, сервисы, репозитории, frontend-компоненты, React Query hooks, формы, тесты) и предложить согласованные правки везде.",
      "Всегда использовать TypeScript на backend и frontend. Не писать новый функционал на JavaScript, за исключением редких вспомогательных скриптов.",
      "Backend-архитектура: Express routes → controllers → services → repositories (Prisma) → database. Zod-схемы используются для описания и валидации входных и выходных данных. express-validator допускается как дополнительная валидация на уровне маршрутов. Не обращаться к Prisma напрямую из routes или controllers.",
      "Все изменения схемы базы данных производятся через Prisma (schema.prisma и миграции). Не использовать сырые SQL-запросы, если нет жёсткой необходимости, и в таком случае оформлять их в отдельном слое с явной типизацией.",
      "Все внешние данные (HTTP-запросы, env-переменные, файлы, ответы внешних API) должны валидироваться. Для runtime-валидации использовать Zod-схемы и/или express-validator. Нельзя полагаться только на типы TypeScript.",
      "Конфигурация окружения: использовать dotenv-safe с .env.example для жёсткой проверки всех обязательных переменных окружения. dotenv может использоваться как fallback в production, но базовое ожидание — корректно заполненный .env.",
      "Логирование на backend выполнять через Winston. Использовать уровни (error, warn, info, debug) и структурированные форматы. В продакшне запрещено оставлять console.log — только Winston. Логи ошибок должны включать стек, request id, user id (если есть) и ключевой контекст.",
      "Безопасность backend: Helmet обязательно включён и корректно настроен. express-rate-limit используется для защиты от брутфорса и DoS. Валидация входных данных — обязательный шаг перед бизнес-логикой. Никаких доверенных данных из тела запроса без проверки.",
      "Для тестирования backend использовать Jest 30+ и ts-jest, а для API — Supertest. При добавлении нового endpoint добавлять минимум один позитивный и один негативный тест. Тесты должны быть повторяемыми и независимыми от внешнего окружения, по возможности использовать тестовую БД.",
      "ESLint 9+ с flat config и строгими правилами TypeScript используется и на backend, и на frontend. Проверка типов включена. Prettier используется для форматирования. Код не должен содержать линт- и формат-ошибок.",
      "Frontend строится на React 19+, TypeScript, React Router 7+, MUI 7+ и Emotion. Для работы с серверным состоянием использовать TanStack Query: useQuery/useMutation и кастомные hooks поверх них. Не выполнять прямые HTTP-вызовы из компонентов, кроме простых случаев.",
      "Глобальное состояние на frontend минимизировать. Context API использовать для аутентификации и глобальных настроек. Zustand применять только при понятной необходимости (сложные UI-оркестрации и кросс-страничные сценарии). Не добавлять Redux без явного требования.",
      "Формы на frontend реализовывать через React Hook Form и @hookform/resolvers с Zod-схемами. Zod-схемы по возможности синхронизировать со схемами backend.",
      "Сборка frontend реализуется через Vite 7+. Вся новая конфигурация сборки, алиасы и плагины настраиваются через vite.config.ts. Не использовать подходы из Create React App.",
      "Тестирование frontend выполняется через Jest 30+ и Testing Library. Компоненты и hooks, реализующие бизнес-логику, должны иметь базовое покрытие. Критичные пользовательские сценарии при необходимости покрываются Playwright.",
      "Docker-конфигурация: использовать multi-stage builds для backend и frontend. В production-образах основой должен быть лёгкий образ (например, Alpine). Для backend предусмотреть health checks и корректную инициализацию Prisma (включая retry-логику при необходимости).",
      "DevOps: базовый деплой через Docker Compose (docker-compose.yml и docker-compose.dev.yml). Для production допускается использование PM2 как process manager. CI/CD (GitHub Actions) настраивается с учётом линтинга, тестов, сборки и создания Docker-образов.",
      "Overrides и резолюции зависимостей (например, glob@^13.0.0) должны быть осознанными и документированными. Нельзя добавлять overrides без понимания их влияния.",
      "Код и идентификаторы (имена файлов, переменных, функций, классов) — на английском. Документация и комментарии могут быть на русском или английском, но желательно придерживаться одного стиля в рамках модуля.",
      "Соблюдать правила разработки проекта: разделение ответственности, модульность, читаемость кода, строгая типобезопасность, безопасность, структурированное логирование и разумное тестовое покрытие. При предложении изменений учитывать существующую структуру SRO/backend и SRO/frontend и следить за тем, чтобы изменения были доведены до конца по всему проекту, а не только показаны как частичный пример."
    ]
  }
  